"Scope is a set of rules that control the ***visibility and lifetime*** of variables, functions, and parameters."
(Bacher, Ivan & Mac Namee, Brian & Kelleher, John. (2017). Scoped: Visualising the scope chain within source code.)

The following tool can be used to visualize the scope of your code:
https://ivanbacher.github.io/p-004-prototype-live/index.html

During JavaScript code execution, as we saw previously, our code is divided into execution contexts and stacked for execution on the Call Stack.

On the last page, we saw that the Execution Context comprehends:
- Variable environment
- Scope chain
- This keyword

![](https://github.com/isamog2/JavaScriptEngine/blob/main/Images/Pasted%20image%2020230328104520.png)

The `second();` **Execution Context:** made of the variable environment, scope chain and any possible "this" keywords the function `second();` might have.

## Zooming in on the 1st element: The Variable environment.

The variable environment is created every time a new function is called, and it holds all the information about the function's local variables, parameters, and inner functions - everything that is in the scope of the code currently being executed.

![](https://github.com/isamog2/JavaScriptEngine/blob/main/Images/Pasted%20image%2020230406111742.png)]

The variable environment is an important concept because when a variable is referenced, the JavaScript engine:

1. First looks for the variable within the current execution context's variable environment - immediate scope;
2. If it can't find the variable within the current environment, it will look-up the **lexical scope,** starting at the next-scope level and continuing until the identifier is found or until the global scope has been reached.

## Zooming in on the 2nd element: The Scope Chain

As we saw on the previous page, compiling is one of the first steps for code execution. 
Tokenizing, or lexing, is a part of this process where source code is broken down into meaningful chunks called "tokens". That's where the term "lexical scope" comes from.

Amongst all programming languages, there are two predominant models for how scope works, **dynamic or lexical.** Lexical scope is just the way that scope behaves in JavaScript.

### Lexical scope

Lexical scoping refers to the way that variable scope is determined by the location of the variable declaration in the source code.

In a lexical scope, variables declared in an outer function are accessible in all inner functions.

### Scope chain
The scope chain is essentially a chain of variable environments that are created as the code is executed. It is created by the engine by taking the current execution context's variable environment -> appending the variable environment of the parent execution context -> creating a chain.

### Zooming in even more: Different types of scopes within the scope chain

The scope is an element of the JavaScript runtime/engine that *"Collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code."*
SIMPSON K.: You Donâ€™t Know JS: Scope & Closures. 2014.

### Global scope
- Outside of any function or block;
- Variables declared in the global scope are accessible everywhere.
- If the identifier is not located anywhere within the lexical scope, the last place to look for is the global scope.
- The engine stops searching after the Global scope, whether it found the identifier or not.
  ![](https://github.com/isamog2/JavaScriptEngine/blob/main/Images/Pasted%20image%2020230406121730.png)
(Picture from SIMPSON K.: You Donâ€™t Know JS: Scope & Closures. 2014). 

### Function scope

- Each function creates a scope;
- This is also its "local scope". It's called this as opposed to the global scope, and due to the fact that local scope generated by code blocks outside of functions behave similarly.
- If the variables inside of the function are declared with "let and const", they can only be accessed from within the function - and from its child functions.
- If a variable is declared with "var", it can also be accessed outside of its enclosing function (we will see this later).
- It is **not correct** to say that only functions create blocks of scope.

```js
function calcAge(birthYear) {
const now = 2037;
const age = now - birthYear;
return age;
}

console.log(now); //ReferenceError: now is not defined
```

The code above would give a "referenceError". This is because we are trying to access the variable `now` from outside of the function `calcAge()`, while this variable is only available inside the function `calcAge().` This is how "function scope" works.

### Block scope (ES6)

- Variables that are only accessible inside a block of code, without it necessarily being a function.
- Functions are considered scope blocks, but not all block scopes come from functions.
- In this case, the if statement is generating a local scope that is also a scope block.
- The variables and functions declared inside of this block, unless they are declared with `var` can only be accessed from within this block.
``` js
if (year >= 1981 && year <= 1996) {
const millennial = true;
const food = 'Avocado toast';
}
console.log(millennial) //ReferenceError: millennial is not defined

```
The same reference error from the function scope would be returned, as we cannot access this variable outside of the "if statement" code block.

### Var, let and const

As you could notice above when it comes to variable declaration, there is a BIG DIFFERENCE between them: VARs are not restricted to scope blocks.
- **Let and const variables are block scoped.** 

If you declare the same variable "millennial" using var in this block instead of const, you could access - and therefore log- the millennial variable.

``` js
if (year >= 1981 && year <= 1996) {
var millennial = true;
const food = 'Avocado toast';
}
console.log(millennial); //now it logs "true".
```